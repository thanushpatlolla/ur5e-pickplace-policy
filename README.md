*This README was generated by Claude Code*

# MuJoCo UR5e Pick and Place Trajectory Collection

A MuJoCo-based simulation for collecting robot trajectory data of a UR5e manipulator with Robotiq 2F85 gripper performing pick-and-place tasks. The collected data is intended for training a Multi-Layer Perceptron (MLP) robot policy.

## Overview

This project simulates a UR5e robot arm picking up randomly positioned and sized objects from a table and placing them at target locations. The simulation uses inverse kinematics (IK) with the Mink library to generate smooth trajectories while avoiding collisions with the environment.

## Features

- **Randomized Object Initialization**: Objects are randomly sized (dimensions and orientation) and placed within the robot's workspace
- **Inverse Kinematics Control**: Uses Mink for efficient IK solving with collision avoidance
- **Collision Avoidance**: Prevents gripper and arm components from colliding with the table surface
- **Velocity Limiting**: Enforces joint velocity constraints for realistic motion
- **Multi-Stage Pick-and-Place**: Executes a complete pick-and-place sequence:
  - Approach object from above
  - Descend to object
  - Grasp with gripper
  - Lift object
  - Move to target location
  - Place and release object
  - Retract

## Project Structure

```
.
├── main.py                  # Entry point - runs multiple simulation episodes
├── run_sim.py              # Main simulation loop with IK control and task execution
├── initialize_object.py    # Randomizes object size, position, and orientation
├── rotation_matrix.py      # Rotation matrix utilities for end-effector orientation control
├── scene.xml               # MuJoCo scene definition
├── ur5e.xml                # UR5e robot model configuration
├── assets/                 # 3D models and textures
├── mujoco_menagerie/       # MuJoCo model zoo (contains UR5e model)
└── robotiq_2f85/           # Robotiq 2F85 gripper model
```

## Dependencies

- `mujoco` - Physics simulation engine
- `mujoco-viewer` - Interactive viewer for MuJoCo simulations
- `numpy` - Numerical computations
- `mink` - Inverse kinematics library with optimization

## Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd mujoco_pick_and_place
```

2. Create a virtual environment and install dependencies:
```bash
python3 -m venv .venv
source .venv/bin/activate  # On Windows: .venv\Scripts\activate
pip install mujoco mujoco-viewer numpy mink
```

## Usage

Run the simulation with:

```bash
python main.py
```

This will execute 100 pick-and-place episodes with randomized object configurations. Each episode:
1. Randomizes object size (width: 1-3cm, depth: 1-3cm, height: 2-5cm)
2. Places object randomly on table within robot reach (25-65cm from base)
3. Executes complete pick-and-place trajectory
4. Repeats with new randomization

### Key Parameters

In `main.py`:
- Random seed: `54321` (for reproducibility)
- Number of episodes: `100`

In `run_sim.py`:
- Time step: Defined by `model.opt.timestep`
- Distance threshold for waypoint completion: `0.02m` (2cm)
- Gripper control: Binary (0 = open, 255 = close)
- Collision avoidance margin: `0.01m` minimum distance

## How It Works

### Object Randomization
The `initialize_object()` function (initialize_object.py:4) creates variation in:
- Object dimensions (cuboid with random width, depth, height)
- Object placement (random position on table within reachable area)
- Object orientation (random yaw rotation)

### Trajectory Generation
The simulation uses task-space control with inverse kinematics:
1. **End-Effector Task**: Targets specific 3D positions and orientations
2. **Posture Task**: Maintains preferred joint configurations
3. **Limits**: Joint limits, velocity limits, and collision avoidance

### Pick-and-Place Sequence
Ten waypoints guide the robot through the task (run_sim.py:115):
0. High above object (40cm)
1. Medium above object (10cm) - enables vertical approach
2. At object center - precise alignment
3. Grasp object - gripper closes
4. Lift object (40cm above initial position)
5. High above target location
6. Medium above target (10cm) - controlled descent
7. Near placement (2cm above table) - prevents premature release
8. At target - gripper opens
9. Retract upward

### Orientation Control
The `get_rotation_matrix()` function (rotation_matrix.py:76) computes end-effector orientation:
- During pickup (steps 1-3): Aligns gripper vertically and matches object orientation
- Other steps: Maintains vertical gripper orientation

## Future Work

- **Data Collection**: Add trajectory recording (joint positions, velocities, end-effector poses)
- **Data Storage**: Save episodes to disk in suitable format (HDF5, npz, etc.)
- **MLP Policy Training**: Train neural network on collected trajectories
- **Curriculum Learning**: Gradually increase task difficulty
- **Visual Observations**: Add camera rendering for vision-based policies

## Notes

- The UR5e has a maximum reach of 85cm, but this implementation limits it to 65cm for reliability
- Contact detection between gripper pads and object ensures successful grasping
- The simulation waits for stable gripper-object contact before proceeding to lift

---